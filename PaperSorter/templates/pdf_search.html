{% extends "base.html" %}
{% set hide_hamburger_menu = true %}

{% block title %}Paper Connect - {{ site_name }}{% endblock %}

{% block header %}{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/pages/feed_struct.css') }}">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            overflow: hidden;
            padding: 0;
        }

        /* Custom header for PDF search */
        .pdf-header {
            background: var(--bg-card);
            border-bottom: 2px solid var(--border-light);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: var(--shadow-card);
            transition: background-color var(--transition-base), border-color var(--transition-base);
        }

        .pdf-header h1 {
            margin: 0;
            color: var(--text-primary);
            font-size: 24px;
            transition: color var(--transition-base);
        }

        .pdf-header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* Main Container */
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
            position: relative;
        }

        /* PDF Column */
        .pdf-column {
            width: 50%;
            min-width: 300px;
            background-color: var(--pdf-column-bg);
            overflow-y: auto;
            position: relative;
            transition: background-color var(--transition-base);
        }

        /* Resize Handle */
        .resize-handle {
            width: 8px;
            background: var(--border-light);
            cursor: col-resize;
            position: relative;
            transition: background-color var(--transition-base);
            flex-shrink: 0;
        }

        .resize-handle:hover {
            background: var(--border-medium);
        }

        .resize-handle:active {
            background: var(--border-dark);
        }

        .resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background: var(--text-meta);
            border-radius: 1px;
            opacity: 0.5;
        }

        /* Upload Area */
        .pdf-upload-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 40px;
        }

        .upload-box {
            background: var(--bg-card);
            padding: 60px;
            border-radius: 10px;
            box-shadow: var(--shadow-card);
            text-align: center;
            max-width: 500px;
            width: 100%;
            transition: background-color var(--transition-base), box-shadow var(--transition-base);
        }

        .upload-box h2 {
            margin-bottom: 30px;
            color: var(--text-primary);
            font-size: 20px;
            transition: color var(--transition-base);
        }

        .pdf-file-input-label {
            display: inline-block;
            padding: 12px 30px;
            background-color: var(--pdf-upload-btn-bg);
            color: var(--text-white);
            border-radius: 6px;
            cursor: pointer;
            transition: background-color var(--transition-base);
            font-size: 16px;
            font-weight: 500;
        }

        .pdf-file-input-label:hover {
            background-color: var(--pdf-upload-btn-hover);
        }

        .pdf-file-name {
            margin-top: 20px;
            color: var(--text-meta);
            font-size: 14px;
            min-height: 20px;
            transition: color var(--transition-base);
        }

        /* PDF Viewer */
        .pdf-viewer {
            padding: 20px;
            min-height: 100%;
            position: relative;
        }

        .pdf-page {
            margin: 0 auto 20px;
            background: var(--bg-card);
            box-shadow: var(--shadow-card);
            position: relative;
            width: fit-content;
            transition: background-color var(--transition-base), box-shadow var(--transition-base);
        }

        .pdf-canvas {
            display: block;
        }

        .pdf-text-layer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1;
        }

        .pdf-text-layer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
        }

        .pdf-text-layer ::selection {
            background: var(--pdf-selection-bg);
        }

        .pdf-text-layer ::-moz-selection {
            background: var(--pdf-selection-bg);
        }

        /* Text Column */
        .text-column {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-card);
            overflow: hidden;
            transition: background-color var(--transition-base);
        }

        .text-panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 20px;
        }

        .text-header {
            margin-bottom: 15px;
        }

        .text-header h3 {
            color: var(--text-primary);
            font-size: 20px;
            margin: 0;
            transition: color var(--transition-base);
        }

        .instruction-text {
            color: var(--text-meta);
            font-size: 14px;
            font-style: italic;
            margin-bottom: 15px;
            padding: 8px 12px;
            background-color: var(--pdf-instruction-bg);
            border-left: 3px solid var(--pdf-instruction-border);
            border-radius: 4px;
            transition: all var(--transition-base);
        }

        .search-section {
            display: none;  /* Hidden - contains only internal textarea */
        }

        .text-area-small {
            display: none !important;  /* Always hidden - internal use only */
        }


        .text-stats {
            display: flex;
            gap: 30px;
            margin-top: 15px;
            padding: 12px;
            background-color: var(--bg-abstract);
            border-radius: 6px;
            font-size: 14px;
            transition: background-color var(--transition-base);
        }

        .word-count, .char-count {
            color: var(--text-meta);
            transition: color var(--transition-base);
        }

        .word-count strong, .char-count strong {
            color: var(--text-primary);
            transition: color var(--transition-base);
        }

        .search-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        /* Search Results - Matching feeds_list.html styles */
        .search-results {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-light);
            transition: border-color var(--transition-base);
        }

        .results-header h4 {
            margin: 0;
            color: var(--text-primary);
            transition: color var(--transition-base);
        }

        .results-count {
            color: var(--text-meta);
            font-size: 14px;
            transition: color var(--transition-base);
        }

        .results-container {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        /* Feed Item Styles - Matching feeds_list.html exactly */
        .feed-item {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-light);
            transition: all var(--transition-base);
            cursor: pointer;
        }

        .feed-item:hover {
            background-color: var(--bg-hover);
        }

        .feed-item:last-child {
            border-bottom: none;
        }


        .score-badge { color: var(--text-white); }



        .score-icon {
            background: var(--pdf-score-icon-bg);
            color: var(--text-white);
            border: 1px solid var(--bg-card);
        }

        .score-icon.shared {
            background: var(--badge-shared-bg);
            color: var(--text-white);
        }

        .score-icon.broadcasted {
            background: var(--badge-broadcasted-bg);
            color: var(--text-white);
        }


        .similarity-badge {
            background: var(--similar-similarity-badge-bg);
            color: var(--text-white);
            min-width: 49px;
        }



        .feed-title {
            color: var(--text-primary);
            transition: color var(--transition-base);
        }

        .feed-meta {
            color: var(--text-meta);
            transition: color var(--transition-base);
        }


        .feed-author {
            max-width: 200px;
        }

        /* Allow author text to wrap when feed is expanded */





        .label-shared {
            background: var(--color-warning);
            color: var(--text-white);
        }

        .label-broadcasted {
            background: var(--color-success);
            color: var(--text-white);
        }

        .label-positive {
            background: var(--color-success);
            color: var(--text-white);
        }

        .label-negative {
            background: var(--color-danger);
            color: var(--text-white);
        }

        .feed-details {
            display: none;
            background: var(--bg-abstract);
            border-top: 1px solid var(--border-light);
            transition: all var(--transition-base);
        }


        .feed-abstract {
            color: var(--text-secondary);
            transition: color var(--transition-base);
        }


        .loading-results {
            text-align: center;
            padding: 40px;
            color: var(--text-meta);
            transition: color var(--transition-base);
        }

        .no-results {
            text-align: center;
            padding: 40px;
            color: var(--text-light);
            font-style: italic;
            transition: color var(--transition-base);
        }

        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s ease;
            vertical-align: middle;
            line-height: 1.5;
            box-sizing: border-box;
        }

        .btn-primary-soft {
            background: var(--similar-btn-primary-bg);
            color: var(--similar-btn-primary-color);
            border: 1px solid var(--similar-btn-primary-border);
        }

        .btn-primary-soft:hover {
            background: var(--similar-btn-primary-hover-bg);
            border-color: var(--similar-btn-primary-hover-border);
        }

        .btn-open-article {
            background: var(--btn-open-article-bg);
            color: var(--btn-open-article-color);
            border: 1px solid var(--btn-open-article-border);
        }

        .btn-open-article:hover {
            background: var(--btn-open-article-bg-hover);
            border-color: var(--btn-open-article-border-hover);
        }

        .btn-secondary-soft {
            background: var(--btn-secondary-bg);
            color: var(--btn-secondary-color);
            border: 1px solid var(--btn-secondary-border);
        }

        .btn-secondary-soft:hover {
            background: var(--btn-secondary-bg-hover);
            border-color: var(--btn-secondary-border-hover);
        }

        /* Match Details button styling from feeds_list */
        .btn-details {
            background: var(--btn-details-bg);
            color: var(--btn-details-color);
            border: 1px solid var(--btn-details-border);
        }

        .btn-details:hover {
            background: var(--btn-details-bg-hover);
            border-color: var(--btn-details-border-hover);
        }

        .btn-share {
            background: var(--similar-btn-share-bg);
            color: var(--similar-btn-share-color);
            border: 1px solid var(--similar-btn-share-border);
        }

        .btn-share:hover {
            background: var(--similar-btn-share-hover-bg);
            border-color: var(--similar-btn-share-hover-border);
        }

        .btn-share.shared {
            background: var(--similar-btn-share-shared-bg);
            border-color: var(--similar-btn-share-shared-border);
            color: var(--similar-btn-share-shared-color);
        }

        .btn-share.disabled,
        .btn-share:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: var(--btn-secondary-bg);
            color: var(--text-meta);
            border-color: var(--border-medium);
        }

        .btn-thumbs-up {
            background: var(--similar-btn-thumbs-up-bg);
            color: var(--similar-btn-thumbs-up-color);
            border: 1px solid var(--similar-btn-thumbs-up-border);
        }

        .btn-thumbs-up:hover {
            background: var(--similar-btn-thumbs-up-hover-bg);
            border-color: var(--similar-btn-thumbs-up-hover-border);
        }

        .btn-thumbs-up.active {
            background: var(--similar-btn-thumbs-up-active-bg);
            border-color: var(--similar-btn-thumbs-up-active-border);
            color: var(--similar-btn-thumbs-up-active-color);
        }

        .btn-thumbs-down {
            background: var(--similar-btn-thumbs-down-bg);
            color: var(--similar-btn-thumbs-down-color);
            border: 1px solid var(--similar-btn-thumbs-down-border);
        }

        .btn-thumbs-down:hover {
            background: var(--similar-btn-thumbs-down-hover-bg);
            border-color: var(--similar-btn-thumbs-down-hover-border);
        }

        .btn-thumbs-down.active {
            background: var(--similar-btn-thumbs-down-active-bg);
            border-color: var(--similar-btn-thumbs-down-active-border);
            color: var(--similar-btn-thumbs-down-active-color);
        }

        .btn-similar {
            background: var(--similar-btn-similar-bg);
            color: var(--similar-btn-similar-color);
            border: 1px solid var(--similar-btn-similar-border);
        }

        .btn-similar:hover {
            background: var(--similar-btn-similar-hover-bg);
            border-color: var(--similar-btn-similar-hover-border);
        }

        .btn-danger {
            background: var(--btn-danger-bg);
            color: var(--text-white);
            border: 1px solid var(--btn-danger-bg);
        }

        .btn-danger:hover {
            background: var(--btn-danger-hover);
            border-color: var(--btn-danger-hover);
        }

        .search-button {
            flex: 1;
        }

        /* Loading spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: var(--text-meta);
            transition: color var(--transition-base);
        }

        /* Error message */
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: var(--color-danger);
            text-align: center;
            padding: 20px;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 3px solid var(--border-light);
            border-top-color: var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }



        /* Responsive Design */
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }

            .pdf-column, .text-column {
                flex: none;
                height: 50vh;
                width: 100% !important;
                min-width: unset;
            }

            .pdf-column {
                border-right: none;
                border-bottom: 2px solid var(--border-light);
            }

            .resize-handle {
                display: none;
            }
        }
    </style>
{% endblock %}

{% block main_container %}
    <div class="pdf-header">
        <h1><a href="/" style="color: inherit; text-decoration: none;">🌌 Paper Connect</a></h1>
        <div class="pdf-header-actions">
            <a href="/" class="nav-link">← Back to Papers</a>
            <button class="btn-theme-toggle" onclick="ThemeManager.toggleTheme()" title="Toggle dark/light mode">
                <span class="theme-icon">🌙</span>
            </button>
        </div>
    </div>

    <div class="main-container" id="mainContainer">
        <div class="pdf-column" id="pdfColumn">
            <div class="pdf-upload-area" id="pdfUploadArea">
                <div class="upload-box">
                    <h2>Open a PDF Document</h2>
                    <label for="pdfFileInput" class="pdf-file-input-label">
                        📄 Choose PDF File
                    </label>
                    <input type="file" id="pdfFileInput" accept=".pdf" hidden>
                    <div id="pdfFileName" class="pdf-file-name"></div>
                    <p style="color: var(--text-meta); font-size: 13px;">
                        Your PDF stays in your browser.<br>
                        Only selected text is sent for searching.
                    </p>
                </div>
            </div>
            <div id="pdfViewerContainer" class="pdf-viewer" style="display: none;">
                <div id="pdfLoadingIndicator" class="loading">Loading PDF...</div>
            </div>
        </div>

        <div class="resize-handle" id="resizeHandle"></div>

        <div class="text-column" id="textColumn">
            <div class="text-panel">
                <div class="text-header">
                    <h3>Search Result</h3>
                </div>
                <div class="instruction-text">
                    Select text in the PDF to search for related papers (minimum 10 characters)
                </div>
                <div class="search-section">
                    <textarea
                        id="textArea"
                        class="text-area-small"
                        placeholder="Selected text from the PDF will appear here."
                    ></textarea>
                </div>
                <div class="search-results" id="searchResults">
                    <div class="results-header" style="display: none;">
                        <h4>Search Results</h4>
                        <span class="results-count" id="resultsCount"></span>
                    </div>
                    <div class="results-container" id="resultsContainer"></div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <!-- Load PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <script>
        // Wait for PDF.js to load
        function waitForPdfJs(callback) {
            if (typeof pdfjsLib !== 'undefined') {
                callback();
            } else {
                setTimeout(() => waitForPdfJs(callback), 100);
            }
        }

        // Configure PDF.js when ready
        waitForPdfJs(() => {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        });

        // Global variables
        let pdfDoc = null;
        let selectedFile = null;
        let isResizing = false;
        let startX = 0;
        let startWidthPdf = 0;
        let currentSearchResults = [];

        // Initialize after DOM is ready
        window.addEventListener('load', function() {
            // Override main styles to remove padding for full-height layout
            const mainElement = document.querySelector('main');
            if (mainElement) {
                mainElement.style.padding = '0';
                mainElement.style.background = 'transparent';
                mainElement.style.boxShadow = 'none';
            }

            // Event Listeners
            const fileInput = document.getElementById('pdfFileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
            }

            // Initialize resize functionality
            initializeResize();
        });

        // File selection handler
        function handleFileSelect(event) {
            const file = event.target.files[0];
            const fileName = document.getElementById('pdfFileName');

            if (file && file.type === 'application/pdf') {
                selectedFile = file;
                if (fileName) fileName.textContent = `Selected: ${file.name}`;
                loadPDFFromFile(file);
            } else {
                selectedFile = null;
                if (fileName) fileName.textContent = 'Please select a valid PDF file';
            }
        }

        // Load PDF from File object
        async function loadPDFFromFile(file) {
            const pdfUploadArea = document.getElementById('pdfUploadArea');
            const pdfViewerContainer = document.getElementById('pdfViewerContainer');
            const pdfLoadingIndicator = document.getElementById('pdfLoadingIndicator');

            try {
                if (pdfUploadArea) pdfUploadArea.style.display = 'none';
                if (pdfViewerContainer) {
                    pdfViewerContainer.style.display = 'block';
                    pdfViewerContainer.innerHTML = '<div class="loading"><div class="loading-spinner"></div>Loading PDF...</div>';
                }
                if (pdfLoadingIndicator) pdfLoadingIndicator.style.display = 'block';

                const arrayBuffer = await file.arrayBuffer();
                const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
                pdfDoc = await loadingTask.promise;

                // Clear viewer and render all pages
                if (pdfViewerContainer) {
                    pdfViewerContainer.innerHTML = '';
                    for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                        await renderPage(pageNum);
                    }
                }
            } catch (error) {
                console.error('Error loading PDF:', error);
                if (pdfViewerContainer) {
                    pdfViewerContainer.innerHTML = '<div class="error">Error loading PDF. Please try again.</div>';
                }
            }
        }

        // Render a single page
        async function renderPage(pageNumber) {
            const pdfViewerContainer = document.getElementById('pdfViewerContainer');
            if (!pdfViewerContainer) return;

            try {
                const page = await pdfDoc.getPage(pageNumber);
                const scale = 1.5;
                const viewport = page.getViewport({ scale });

                // Create page container
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.style.width = viewport.width + 'px';
                pageDiv.style.height = viewport.height + 'px';

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.className = 'pdf-canvas';
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;

                // Render PDF page to canvas
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                await page.render(renderContext).promise;

                // Create text layer for selection
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'pdf-text-layer';

                // Get text content
                const textContent = await page.getTextContent();

                // Render text layer
                pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: textLayerDiv,
                    viewport: viewport,
                    textDivs: []
                });

                // Add event listeners for text selection
                setupTextSelection(textLayerDiv);

                pageDiv.appendChild(canvas);
                pageDiv.appendChild(textLayerDiv);
                pdfViewerContainer.appendChild(pageDiv);
            } catch (error) {
                console.error(`Error rendering page ${pageNumber}:`, error);
            }
        }

        // Setup text selection handlers
        function setupTextSelection(textLayer) {
            // Handle mouse up (drag selection)
            textLayer.addEventListener('mouseup', function() {
                handleTextSelect();
            });

            // Handle double click (word selection)
            textLayer.addEventListener('dblclick', function(event) {
                setTimeout(() => {
                    handleTextSelect();
                }, 10);
            });
        }

        // Handle text selection
        function handleTextSelect() {
            const selection = window.getSelection();
            let selectedText = selection.toString().trim();

            // Limit to 4000 characters if text is too long
            const MAX_TEXT_LENGTH = 4000;
            if (selectedText.length > MAX_TEXT_LENGTH) {
                selectedText = selectedText.substring(0, MAX_TEXT_LENGTH);
                console.log(`Text truncated from ${selection.toString().trim().length} to ${MAX_TEXT_LENGTH} characters`);
            }

            const textArea = document.getElementById('textArea');

            if (selectedText && selectedText.length >= 10) {
                if (textArea) {
                    textArea.value = selectedText; // Store text for internal use (max 4000 chars)
                }
                // Automatically perform search when text is selected
                performSearch();
            }
        }


        // Feed action functions
        function shareFeed(feedId, button, isBroadcasted) {
            // Prevent event bubbling if needed
            if (event) event.stopPropagation();

            // Prevent sharing if already broadcasted
            if (isBroadcasted) {
                return;
            }

            const isShared = button.getAttribute('data-shared') === 'true';
            const feedItem = button.closest('.feed-item');
            const similarityBadge = feedItem.querySelector('.similarity-badge');

            fetch(`/api/feeds/${feedId}/share`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ action: 'toggle' })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    const newShared = data.action === 'share';
                    button.setAttribute('data-shared', newShared.toString());
                    if (newShared) {
                        button.classList.add('shared');
                        button.innerHTML = '📤';
                        button.title = 'Shared';
                        // Add shared icon to similarity badge
                        if (similarityBadge) {
                            let iconsContainer = similarityBadge.querySelector('.score-icons');
                            if (!iconsContainer) {
                                iconsContainer = document.createElement('div');
                                iconsContainer.className = 'score-icons';
                                similarityBadge.appendChild(iconsContainer);
                            }
                            if (!iconsContainer.querySelector('.score-icon.shared')) {
                                const sharedIcon = document.createElement('div');
                                sharedIcon.className = 'score-icon shared';
                                sharedIcon.title = 'In Queue';
                                sharedIcon.textContent = '📤';
                                iconsContainer.appendChild(sharedIcon);
                            }
                        }
                    } else {
                        button.classList.remove('shared');
                        button.innerHTML = '📤';
                        button.title = 'Share';
                        // Remove shared icon from similarity badge
                        if (similarityBadge) {
                            const sharedIcon = similarityBadge.querySelector('.score-icon.shared');
                            if (sharedIcon) {
                                sharedIcon.remove();
                                // Remove icons container if empty
                                const iconsContainer = similarityBadge.querySelector('.score-icons');
                                if (iconsContainer && iconsContainer.children.length === 0) {
                                    iconsContainer.remove();
                                }
                            }
                        }
                    }
                }
            })
            .catch(error => console.error('Error sharing feed:', error));
        }

        function feedbackFeed(feedId, score, button) {
            const currentLabel = parseInt(button.getAttribute('data-label'));
            const newScore = currentLabel === score ? null : score;

            fetch(`/api/feeds/${feedId}/feedback`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ score: newScore })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update both thumbs buttons
                    const feedItem = button.closest('.feed-item');
                    const thumbsUp = feedItem.querySelector('.btn-thumbs-up');
                    const thumbsDown = feedItem.querySelector('.btn-thumbs-down');
                    const labelsContainer = feedItem.querySelector('.feed-labels');
                    const feedHeader = feedItem.querySelector('.feed-header');

                    // Reset both buttons
                    thumbsUp.classList.remove('active');
                    thumbsDown.classList.remove('active');
                    thumbsUp.setAttribute('data-label', newScore);
                    thumbsDown.setAttribute('data-label', newScore);

                    // Set active state on the appropriate button
                    if (newScore === 1) {
                        thumbsUp.classList.add('active');
                    } else if (newScore === 0) {
                        thumbsDown.classList.add('active');
                    }

                    // Update vote badges
                    let newLabelsHtml = '';
                    const positiveVotes = parseInt(feedItem.getAttribute('data-positive-votes') || '0');
                    const negativeVotes = parseInt(feedItem.getAttribute('data-negative-votes') || '0');

                    if (newScore === 1 || positiveVotes > 0) {
                        const count = newScore === 1 ? Math.max(1, positiveVotes) : positiveVotes;
                        newLabelsHtml += `<span class="label-badge label-positive">+${count}</span>`;
                    }
                    if (newScore === 0 || negativeVotes > 0) {
                        const count = newScore === 0 ? Math.max(1, negativeVotes) : negativeVotes;
                        newLabelsHtml += `<span class="label-badge label-negative">−${count}</span>`;
                    }

                    if (newLabelsHtml) {
                        if (labelsContainer) {
                            labelsContainer.innerHTML = newLabelsHtml;
                        } else {
                            const newLabelsContainer = document.createElement('div');
                            newLabelsContainer.className = 'feed-labels';
                            newLabelsContainer.innerHTML = newLabelsHtml;
                            feedHeader.appendChild(newLabelsContainer);
                        }
                    } else if (labelsContainer) {
                        labelsContainer.remove();
                    }
                }
            })
            .catch(error => console.error('Error providing feedback:', error));
        }

        function viewDetails(feedId) {
            // Open paper details page in a new tab
            window.open(`/paper/${feedId}`, '_blank');
        }

        // Perform semantic search
        async function performSearch() {
            const textArea = document.getElementById('textArea');
            const resultsContainer = document.getElementById('resultsContainer');

            if (!textArea || !resultsContainer) return;

            let query = textArea.value.trim();

            // Ensure query doesn't exceed 4000 characters (should already be limited, but double-check)
            const MAX_TEXT_LENGTH = 4000;
            if (query.length > MAX_TEXT_LENGTH) {
                query = query.substring(0, MAX_TEXT_LENGTH);
            }

            if (query.length < 10) {
                return;
            }

            // Show loading
            resultsContainer.innerHTML = '<div class="loading-results">Searching for similar papers...</div>';
            const resultsHeader = document.querySelector('.results-header');
            if (resultsHeader) resultsHeader.style.display = 'flex';

            try {
                // Use POST method to handle long text
                const response = await fetch('/api/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ query: query })
                });
                const data = await response.json();

                if (response.ok && data.feeds) {
                    displaySearchResults(data.feeds);
                } else {
                    resultsContainer.innerHTML = `<div class="no-results">Search failed: ${data.error || 'Unknown error'}</div>`;
                }
            } catch (error) {
                console.error('Search error:', error);
                resultsContainer.innerHTML = '<div class="no-results">Failed to perform search. Please try again.</div>';
            }
        }

        // Use the common gradient color functions from common.js
        function getGradientColor(score) {
            return getScoreGradientColor(score);
        }

        function getSimilarityColor(similarity) {
            return getSimilarityGradientColor(similarity);
        }


        // Create feed element matching feeds_list.html
        function createFeedElement(feed) {
            // Create icons for similarity badge
            let icons = [];
            if (feed.shared) icons.push('<div class="score-icon shared" title="In Queue">📤</div>');
            if (feed.broadcasted) icons.push('<div class="score-icon broadcasted" title="Broadcasted">📡</div>');
            const iconsHtml = icons.length > 0 ? `<div class="score-icons">${icons.join('')}</div>` : '';

            let labels = [];

            // Show vote badges with counts on the far right
            if (feed.positive_votes > 0 || feed.label === 1) {
                const count = feed.positive_votes || 1;
                labels.push(`<span class="label-badge label-positive">+${count}</span>`);
            }
            if (feed.negative_votes > 0 || feed.label === 0) {
                const count = feed.negative_votes || 1;
                labels.push(`<span class="label-badge label-negative">−${count}</span>`);
            }

            // Create badges HTML - only show similarity badge for PDF search
            let badgesHtml = '';
            if (feed.similarity !== undefined && feed.similarity !== null) {
                const similarityText = Math.round(feed.similarity * 100).toString();
                const similarityColor = getSimilarityColor(feed.similarity);
                badgesHtml = `
                    <div class="similarity-badge score-badge" style="background: ${similarityColor}">
                        ${similarityText}
                        ${iconsHtml}
                    </div>
                `;
            }

            return `
                <div class="feed-item" data-feed-rowid="${feed.rowid}" data-positive-votes="${feed.positive_votes || 0}" data-negative-votes="${feed.negative_votes || 0}">
                    <div class="feed-header">
                        ${badgesHtml}
                        <div class="feed-content">
                            <div class="feed-title">${safeHtml(feed.title)}</div>
                            <div class="feed-meta">
                                <div class="feed-meta-item feed-origin">${escapeHtml(feed.origin || feed.venue || (feed.journal && feed.journal.name) || 'Unknown Source')}</div>
                                ${feed.author ? `<div class="feed-meta-item feed-author" title="${escapeHtml(feed.author)}">${escapeHtml(formatAuthors(feed.author))}</div>` : ''}
                                <div class="feed-meta-item feed-date">${formatDate(feed.published || feed.added)}</div>
                            </div>
                        </div>
                        ${labels.length > 0 ? `<div class="feed-labels">${labels.join('')}</div>` : ''}
                    </div>
                    <div class="feed-details" data-feed-id="${feed.rowid}" data-loaded="false">
                        <div class="feed-abstract">Loading content...</div>
                        <div class="feed-actions">
                            <button class="btn btn-details" onclick="viewDetails(${feed.rowid})" onmousedown="handleDetailsClick(event, ${feed.rowid})" title="Details">
                                📄
                            </button>
                            ${feed.link ? `<a href="${feed.link}" target="_blank" class="btn btn-open-article" title="Open Paper">📄</a>` : ''}
                            <button class="btn btn-share ${feed.shared ? 'shared' : ''} ${feed.broadcasted ? 'disabled' : ''}"
                                    onclick="shareFeed(${feed.rowid}, this, ${feed.broadcasted})"
                                    data-shared="${feed.shared ? 'true' : 'false'}"
                                    ${feed.broadcasted ? 'disabled' : ''}
                                    title="${feed.broadcasted ? 'Already broadcasted' : (feed.shared ? 'Shared' : 'Share')}">
                                ${feed.broadcasted ? '📡' : '📤'}
                            </button>
                            <button class="btn btn-thumbs-up ${feed.label === 1 ? 'active' : ''}" onclick="feedbackFeed(${feed.rowid}, 1, this)" data-label="${feed.label}" title="Interested">
                                👍
                            </button>
                            <button class="btn btn-thumbs-down ${feed.label === 0 ? 'active' : ''}" onclick="feedbackFeed(${feed.rowid}, 0, this)" data-label="${feed.label}" title="Not Interested">
                                👎
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // Display search results
        function displaySearchResults(feeds) {
            const resultsContainer = document.getElementById('resultsContainer');
            const resultsCount = document.getElementById('resultsCount');

            if (!resultsContainer) return;

            if (!feeds || feeds.length === 0) {
                resultsContainer.innerHTML = '<div class="no-results">No similar papers found.</div>';
                if (resultsCount) resultsCount.textContent = '0 papers';
                currentSearchResults = [];
                return;
            }

            // Store results globally for access in event handlers
            currentSearchResults = feeds;

            if (resultsCount) resultsCount.textContent = `${feeds.length} papers`;
            resultsContainer.innerHTML = feeds.map(feed => createFeedElement(feed)).join('');

            // Add click handlers to expand/collapse feed details
            document.querySelectorAll('.feed-item').forEach((item, index) => {
                const header = item.querySelector('.feed-header');
                const details = item.querySelector('.feed-details');
                const feedId = item.getAttribute('data-feed-rowid');
                const feed = feeds[index]; // Get the corresponding feed data

                header.addEventListener('click', async function(e) {
                    // Don't expand if clicking on buttons or links
                    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A' ||
                        e.target.closest('button') || e.target.closest('a')) {
                        return;
                    }

                    // Toggle expanded state
                    details.classList.toggle('expanded');
                    item.classList.toggle('expanded');

                    // Toggle author display
                    const authorElement = header.querySelector('.feed-author');
                    if (feed && feed.author && authorElement) {
                        if (details.classList.contains('expanded')) {
                            // Show full author list when expanded
                            authorElement.textContent = feed.author;
                        } else {
                            // Show shortened author list when collapsed
                            authorElement.textContent = formatAuthors(feed.author);
                        }
                    }

                    // Load content if expanding and not already loaded
                    if (details.classList.contains('expanded') && details.getAttribute('data-loaded') !== 'true') {
                        const abstractDiv = details.querySelector('.feed-abstract');

                        // Fetch content from API
                        try {
                            const response = await fetch(`/api/feeds/${feedId}/content`);

                            if (response.ok) {
                                const data = await response.json();
                                if (data.content) {
                                    abstractDiv.textContent = data.content;
                                    details.setAttribute('data-loaded', 'true');
                                } else if (data.tldr) {
                                    abstractDiv.textContent = `TL;DR: ${data.tldr}`;
                                    details.setAttribute('data-loaded', 'true');
                                } else {
                                    abstractDiv.textContent = 'No abstract available';
                                }
                            } else {
                                console.error('Failed to fetch content, status:', response.status);
                                abstractDiv.textContent = 'No abstract available';
                            }
                        } catch (error) {
                            console.error('Error loading feed content:', error);
                            abstractDiv.textContent = 'Failed to load content';
                        }
                    }
                });
            });
        }

        // Resize functionality
        function initializeResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const pdfColumn = document.getElementById('pdfColumn');
            const mainContainer = document.getElementById('mainContainer');

            if (!resizeHandle || !pdfColumn || !mainContainer) return;

            // Mouse events
            resizeHandle.addEventListener('mousedown', startResize);

            // Touch events for mobile
            resizeHandle.addEventListener('touchstart', startResize, { passive: false });

            function startResize(e) {
                isResizing = true;

                // Get starting position
                startX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                startWidthPdf = pdfColumn.offsetWidth;

                // Prevent text selection while resizing
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'col-resize';

                // Add active state to handle
                resizeHandle.style.background = getComputedStyle(document.documentElement).getPropertyValue('--border-dark');

                // Add event listeners for move and end
                if (e.type.includes('touch')) {
                    document.addEventListener('touchmove', doResize, { passive: false });
                    document.addEventListener('touchend', stopResize);
                } else {
                    document.addEventListener('mousemove', doResize);
                    document.addEventListener('mouseup', stopResize);
                }

                e.preventDefault();
            }

            function doResize(e) {
                if (!isResizing) return;

                const currentX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const diffX = currentX - startX;
                const containerWidth = mainContainer.offsetWidth;

                // Calculate new width as percentage
                let newWidthPdf = startWidthPdf + diffX;

                // Apply constraints (min 300px, max 80% of container)
                const minWidth = 300;
                const maxWidth = containerWidth * 0.8;

                newWidthPdf = Math.max(minWidth, Math.min(maxWidth, newWidthPdf));

                // Set the new width
                pdfColumn.style.width = newWidthPdf + 'px';

                e.preventDefault();
            }

            function stopResize() {
                if (!isResizing) return;

                isResizing = false;

                // Restore cursor and selection
                document.body.style.userSelect = '';
                document.body.style.cursor = '';

                // Remove active state from handle
                resizeHandle.style.background = '';

                // Remove event listeners
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', stopResize);
                document.removeEventListener('touchmove', doResize);
                document.removeEventListener('touchend', stopResize);

                // Save the width to localStorage for persistence
                const pdfColumn = document.getElementById('pdfColumn');
                if (pdfColumn) {
                    localStorage.setItem('pdfColumnWidth', pdfColumn.style.width);
                }
            }

            // Restore saved width from localStorage
            const savedWidth = localStorage.getItem('pdfColumnWidth');
            if (savedWidth) {
                pdfColumn.style.width = savedWidth;
            }
        }
    </script>
{% endblock %}
