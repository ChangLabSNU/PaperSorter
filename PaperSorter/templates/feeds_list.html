<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QBio Feeds - PaperSorter</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .filter-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .score-filter {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .score-filter-label {
            font-size: 14px;
            color: #7f8c8d;
            font-weight: bold;
        }

        .score-slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .score-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-value {
            font-size: 12px;
            color: #2c3e50;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            color: #2c3e50;
        }

        .nav-link {
            color: #3498db;
            text-decoration: none;
            font-weight: bold;
            padding: 10px 20px;
            border: 2px solid #3498db;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .nav-link:hover {
            background: #3498db;
            color: white;
        }

        .user-info {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: #e8f5e9;
            border-radius: 20px;
            font-weight: 600;
            color: #2e7d32;
            font-size: 14px;
            gap: 8px;
        }

        .user-icon {
            width: 24px;
            height: 24px;
            background: #4caf50;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        button.user-info:hover {
            background: #bbdefb !important;
            transition: background 0.2s ease;
        }

        .feeds-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .date-header {
            background: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            font-weight: bold;
            color: #2c3e50;
            font-size: 16px;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .bookmark-divider {
            border-top: 3px solid #3498db;
            margin: 0;
            padding: 10px 20px;
            background: #e3f2fd;
            color: #1976d2;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            position: relative;
        }

        .bookmark-divider::before {
            content: 'üìñ';
            margin-right: 8px;
        }

        .feed-item {
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .feed-item:hover {
            background-color: #f8f9fa;
        }

        .feed-item.expanded {
            background-color: #f0f4f8;
        }

        .feed-item:last-child {
            border-bottom: none;
        }

        .feed-header {
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
        }

        .score-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            color: white;
            min-width: 50px;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
        }

        .score-icons {
            position: absolute;
            top: -8px;
            right: -8px;
            display: flex;
            gap: 2px;
        }

        .score-icon {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border: 1px solid white;
        }

        .score-icon.starred {
            background: #f39c12;
            color: white;
        }

        .score-icon.broadcasted {
            background: #1f295a;
            color: white;
        }

        .similarity-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-width: 49px;
        }

        .badges-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .feed-content {
            flex: 1;
            min-width: 0;
        }

        .feed-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
            line-height: 1.3;
        }

        .feed-meta {
            display: flex;
            gap: 15px;
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .feed-meta-item {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .feed-author {
            max-width: 200px;
        }

        .feed-origin {
            font-weight: bold;
        }

        .feed-date {
            flex-shrink: 0;
        }

        .feed-labels {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: auto;
            flex-shrink: 0;
        }

        .label-badge {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }

        .label-starred {
            background: #f39c12;
            color: white;
        }

        .label-positive {
            background: #27ae60;
            color: white;
        }

        .label-negative {
            background: #e74c3c;
            color: white;
        }

        .feed-details {
            display: none;
            padding: 20px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }

        .feed-details.expanded {
            display: block;
        }

        .feed-abstract {
            font-size: 15px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 15px;
        }

        .feed-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid transparent;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.2s ease;
            vertical-align: middle;
            line-height: 1.5;
            box-sizing: border-box;
        }

        .btn-primary {
            background: #e3f2fd;
            color: #1976d2;
            border: 1px solid #90caf9;
        }

        .btn-primary:hover {
            background: #bbdefb;
            border-color: #64b5f6;
        }

        .btn-star {
            background: #fff3e0;
            color: #f57c00;
            border: 1px solid #ffcc80;
        }

        .btn-star:hover {
            background: #ffe0b2;
            border-color: #ffb74d;
        }

        .btn-star.starred {
            background: #ffcc80;
            border-color: #ff9800;
            color: #e65100;
        }

        .btn-thumbs-up {
            background: #e8f5e9;
            color: #388e3c;
            border: 1px solid #a5d6a7;
        }

        .btn-thumbs-up:hover {
            background: #c8e6c9;
            border-color: #81c784;
        }

        .btn-thumbs-up.active {
            background: #a5d6a7;
            border-color: #66bb6a;
            color: #2e7d32;
        }

        .btn-thumbs-down {
            background: #ffebee;
            color: #d32f2f;
            border: 1px solid #ef9a9a;
        }

        .btn-thumbs-down:hover {
            background: #ffcdd2;
            border-color: #e57373;
        }

        .btn-thumbs-down.active {
            background: #ef9a9a;
            border-color: #ef5350;
            color: #c62828;
        }

        .btn-similar {
            background: #f3e5f5;
            color: #7b1fa2;
            border: 1px solid #ce93d8;
        }

        .btn-similar:hover {
            background: #e1bee7;
            border-color: #ba68c8;
        }

        .btn-secondary {
            background: #ecf0f1;
            color: #34495e;
            border: 1px solid #bdc3c7;
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 10000;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            max-width: 300px;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.success {
            background: #4caf50;
        }

        .toast.error {
            background: #f44336;
        }

        .btn-secondary:hover {
            background: #d5dbdb;
            border-color: #95a5a6;
        }

        .search-interface {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        .search-input {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .search-input:focus {
            border-color: #3498db;
        }

        .search-textarea {
            flex: 1;
            padding: 10px 15px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.2s ease;
            min-height: 80px;
            max-height: 300px;
            resize: vertical;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.5;
        }

        .search-textarea:focus {
            border-color: #3498db;
        }

        .search-btn {
            align-self: flex-start;
        }

        .search-results-header {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .search-results-header h2 {
            margin: 0;
            color: #2c3e50;
        }

        .search-result-item {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
        }

        .search-result-item:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border-color: #3498db;
        }

        .search-result-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .search-result-meta {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 10px;
        }

        .search-result-abstract {
            font-size: 14px;
            line-height: 1.6;
            color: #34495e;
            margin-bottom: 15px;
            max-height: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn-add {
            background: #27ae60;
            color: white;
            border: 1px solid #229954;
        }

        .btn-add:hover {
            background: #2ecc71;
            border-color: #27ae60;
        }

        .btn-add:disabled {
            background: #95a5a6;
            border-color: #7f8c8d;
            cursor: not-allowed;
        }

        .already-added-badge {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-size: 16px;
        }

        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        .btn-text {
            margin-left: 5px;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .filter-controls {
                flex-direction: column;
                gap: 15px;
            }

            .search-interface {
                flex-direction: column;
                gap: 15px;
            }

            .search-input, .search-textarea {
                width: 100%;
            }

            .search-btn {
                width: 100%;
            }

            .search-results-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .search-result-actions {
                flex-wrap: wrap;
            }

            .score-slider {
                width: 150px;
            }

            .feed-header {
                padding: 15px;
                flex-direction: column;
                align-items: flex-start;
            }

            .score-badge {
                margin-bottom: 7.5px;
                min-width: 42px;
                padding: 4px 8px;
            }

            .badges-container {
                margin-bottom: 7.5px;
            }

            .similarity-badge,
            .score-badge {
                min-width: 35px;
                padding: 4px 8px;
            }

            .feed-content {
                width: 100%;
            }

            .feed-meta {
                flex-direction: column;
                gap: 5px;
            }

            .feed-meta-item {
                max-width: none;
            }

            .feed-labels {
                position: absolute;
                top: 15px;
                right: 15px;
                margin: 0;
                width: auto;
            }

            .feed-actions {
                flex-wrap: wrap;
                gap: 5px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 16px;
                min-width: 44px;
                text-align: center;
            }

            .btn-text {
                display: none;
            }

            .btn-primary {
                background: #e3f2fd;
                color: #1976d2;
                border-color: #90caf9;
            }

            .btn-primary:hover {
                background: #bbdefb;
                border-color: #64b5f6;
            }

            .btn-star.starred {
                background: #f39c12;
                color: white;
                border-color: #f39c12;
            }

            .btn-thumbs-up.active {
                background: #27ae60;
                color: white;
                border-color: #27ae60;
            }

            .btn-thumbs-down.active {
                background: #e74c3c;
                color: white;
                border-color: #e74c3c;
            }
        }

        /* Summary Section Styles */
        .summary-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .summary-header h3 {
            margin: 0;
            color: #1a73e8;
            font-size: 20px;
        }

        .summary-content {
            position: relative;
            min-height: 120px;
        }

        .summary-initial {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 120px;
            gap: 12px;
        }

        .btn-generate {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            border-radius: 24px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn-generate:hover {
            background: #1557b0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }

        .btn-generate:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .summary-loading, .poster-loading {
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto 20px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #1a73e8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .summary-text {
            font-size: 15px;
            line-height: 1.8;
            color: #202124;
        }

        .summary-text h1, .summary-text h2, .summary-text h3 {
            color: #1a73e8;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .summary-text ul {
            margin: 10px 0;
            padding-left: 25px;
        }

        .summary-text li {
            margin: 5px 0;
        }

        .summary-text strong {
            color: #3c4043;
        }

        .summary-disclaimer {
            margin-top: 20px;
            padding: 12px 16px;
            background-color: #f8f9fa;
            border-left: 3px solid #dadce0;
            border-radius: 4px;
        }

        .summary-disclaimer p {
            margin: 0;
            font-size: 13px;
            color: #5f6368;
            line-height: 1.5;
        }

        .summary-disclaimer strong {
            color: #3c4043;
        }

        .poster-content {
            width: 100%;
            margin-top: 20px;
        }

        .poster-iframe {
            width: 100%;
            height: 800px;
            border: 1px solid #dadce0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>QBio Feeds</h1>
            <div class="filter-controls">
                <div class="score-filter">
                    <div class="score-filter-label">Min Score</div>
                    <input type="range" id="scoreSlider" class="score-slider" min="0" max="4" value="2" step="1">
                    <div class="score-value" id="scoreValue">0.05</div>
                </div>
                <div class="score-filter">
                    <div class="score-filter-label">Channel</div>
                    <select id="primaryChannelSelect" class="channel-selector" style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd;">
                        {% if not channels %}
                        <option value="">None</option>
                        {% endif %}
                        {% for channel in channels %}
                        <option value="{{ channel.id }}" {% if channel.id == primary_channel_id %}selected{% endif %}>
                            {{ channel.name }}
                        </option>
                        {% endfor %}
                    </select>
                </div>
                <div class="user-info">
                    <div class="user-icon">{{ current_user.username[0].upper() }}</div>
                    <span>{{ current_user.username }}</span>
                </div>
                <button id="generalSearchToggleBtn" class="user-info" onclick="toggleGeneralSearch()" style="cursor: pointer; background: #e3f2fd; border: none; outline: none;">
                    <span style="margin-left: 0;">üîç Search</span>
                </button>
                {% if current_user.is_admin %}
                <button id="searchToggleBtn" class="user-info" onclick="toggleSemanticSearch()" style="cursor: pointer; background: #e3f2fd; border: none; outline: none;">
                    <span style="margin-left: 0;">üî¨ Add</span>
                </button>
                <a href="/settings" class="nav-link">‚öôÔ∏è Settings</a>
                {% endif %}
                <a href="/logout" class="nav-link">üö™ Logout</a>
            </div>
        </div>

        <!-- General Search Interface -->
        <div id="generalSearchContainer" style="display: none;">
            <div class="search-interface">
                <textarea id="generalSearchInput" placeholder="Search by title, abstract, or any text. Press Enter to search, Shift+Enter for new line." class="search-textarea"></textarea>
                <button onclick="performGeneralSearch()" class="btn btn-primary search-btn">üîç Search</button>
            </div>
        </div>

        <!-- General Search Results Container -->
        <div id="generalSearchResultsContainer" style="display: none;">
            <div class="search-results-header">
                <div style="flex: 1;">
                    <h2 style="margin-bottom: 8px;">Search Results</h2>
                    <p id="searchQueryDisplay" style="margin: 0; color: #7f8c8d; font-size: 14px;"></p>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button onclick="copySearchLink()" class="btn btn-primary">üìã Copy Link</button>
                    <button onclick="backToFeedList()" class="btn btn-secondary">‚Üê Back to Feed List</button>
                </div>
            </div>

            <!-- Summary Section -->
            <div class="summary-section" id="searchSummarySection" style="display: none;">
                <div class="summary-header">
                    <h3>AI Summary</h3>
                </div>
                <div class="summary-content" id="searchSummaryContent">
                    <div class="summary-initial" id="searchSummaryInitial">
                        <button class="btn btn-primary btn-generate" id="generateSearchSummaryBtn">Generate Summary</button>
                        <button class="btn btn-primary btn-generate" id="generateSearchPosterBtn">Generate Infographic</button>
                    </div>
                    <div class="summary-loading" id="searchSummaryLoading" style="display: none;">
                        <div class="spinner"></div>
                        <p>Generating summary...</p>
                    </div>
                    <div class="poster-loading" id="searchPosterLoading" style="display: none;">
                        <div class="spinner"></div>
                        <p>Generating infographic poster...</p>
                        <p style="font-size: 13px; color: #5f6368; margin-top: 10px;">
                            This may take 3-5 minutes. Please wait...
                        </p>
                    </div>
                    <div class="summary-text" id="searchSummaryText"></div>
                    <div class="poster-content" id="searchPosterContent" style="display: none;"></div>
                </div>
            </div>

            <div class="feeds-container">
                <div id="generalSearchResults">
                    <!-- Search results will be loaded here -->
                </div>
            </div>
        </div>

        <!-- Scholarly Database Search Interface -->
        <div id="semanticSearchContainer" style="display: none;">
            <div class="search-interface">
                <input type="text" id="semanticSearchInput" placeholder="Search for papers in scholarly database..." class="search-input">
                <button onclick="performSemanticSearch()" class="btn btn-primary">üîç Search</button>
                <button onclick="backToFeedList()" class="btn btn-secondary">‚Üê Back to Feed List</button>
            </div>
        </div>

        <!-- Search Results Container -->
        <div id="searchResultsContainer" style="display: none;">
            <div class="search-results-header">
                <h2 id="searchResultsTitle">Scholarly Database Search Results</h2>
                <button onclick="backToSearchInput()" class="btn btn-secondary">‚Üê Back to Search</button>
                <button onclick="backToFeedList()" class="btn btn-secondary">‚Üê Back to Feed List</button>
            </div>
            <div id="searchResults">
                <!-- Search results will be loaded here -->
            </div>
        </div>

        <div class="feeds-container" id="feedsContainer">
            <div id="feeds-list">
                <!-- Feeds will be loaded here -->
            </div>
            <div id="loading" class="loading">
                <div class="loading-spinner"></div>
                Loading feeds...
            </div>
        </div>
    </div>

    <script>
        let currentPage = 1;
        let isLoading = false;
        let hasMore = true;
        let currentMinScore = {{ current_user.feedlist_minscore or 0.25 }};
        let lastDateShown = null;
        let bookmarkId = null;
        let bookmarkInserted = false;
        const userTimezone = '{{ current_user.timezone }}';

        // Score threshold values corresponding to slider positions
        const scoreThresholds = [0, 0.05, 0.1, 0.25, 0.5];
        const scoreLabels = ['Unlimited', '‚â• 5', '‚â• 10', '‚â• 25', '‚â• 50'];

        function calculateScoreColor(score) {
            if (score === null) return 'rgb(149, 165, 166)';

            // Apply gamma transformation to weight towards red (0.7 = lighter colors)
            const gamma = Math.pow(Math.max(0, Math.min(1, score)), 0.7);
            // Interpolate between gray (149,165,166) and red (231,116,60)
            const r = Math.round(149 + (231 - 149) * gamma);
            const g = Math.round(165 + (116 - 165) * gamma);
            const b = Math.round(166 + (60 - 166) * gamma);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);

            // Format date in user's timezone to YYYY-mm-dd
            const options = {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                timeZone: userTimezone || 'UTC'
            };

            // Get the parts and reformat to YYYY-mm-dd
            const parts = date.toLocaleDateString('en-US', options).split('/');
            if (parts.length === 3) {
                const [month, day, year] = parts;
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }
            return date.toLocaleDateString('en-US', options).replace(/\//g, '-');
        }

        function showToast(message, type = 'success') {
            // Remove any existing toasts
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create new toast
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Show toast
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Hide and remove toast after 3 seconds
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 3000);
        }

        function formatDateHeader(timestamp) {
            if (!timestamp) return 'Unknown Date';
            const date = new Date(timestamp * 1000);

            // Get today and yesterday in user's timezone
            const now = new Date();
            const todayStr = now.toLocaleDateString('en-US', { timeZone: userTimezone || 'UTC' });
            const dateStr = date.toLocaleDateString('en-US', { timeZone: userTimezone || 'UTC' });

            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toLocaleDateString('en-US', { timeZone: userTimezone || 'UTC' });

            // Check if it's today
            if (dateStr === todayStr) {
                return 'Today';
            }
            // Check if it's yesterday
            else if (dateStr === yesterdayStr) {
                return 'Yesterday';
            }
            // Otherwise show the date
            else {
                return date.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    timeZone: userTimezone || 'UTC'
                });
            }
        }

        function getDateKey(timestamp) {
            if (!timestamp) return 'unknown';
            const date = new Date(timestamp * 1000);
            // Use timezone-aware date string for grouping
            return date.toLocaleDateString('en-US', { timeZone: userTimezone || 'UTC' });
        }

        function createFeedElement(feed) {
            const scoreColor = calculateScoreColor(feed.score);
            const scoreText = feed.score !== null ? Math.round(feed.score * 100).toString() : 'N/A';

            // Create icons for score badge
            let icons = [];
            if (feed.starred) icons.push('<div class="score-icon starred">‚òÖ</div>');
            if (feed.broadcasted) icons.push('<div class="score-icon broadcasted">üì°</div>');
            const iconsHtml = icons.length > 0 ? `<div class="score-icons">${icons.join('')}</div>` : '';

            let labels = [];
            if (feed.starred) labels.push('<span class="label-badge label-starred">‚òÖ</span>');

            // Show vote badges with counts (including current user's vote)
            if (feed.positive_votes > 0 || feed.label === 1) {
                const count = feed.positive_votes || 0;
                labels.push(`<span class="label-badge label-positive">+${count}</span>`);
            }
            if (feed.negative_votes > 0 || feed.label === 0) {
                const count = feed.negative_votes || 0;
                labels.push(`<span class="label-badge label-negative">‚àí${count}</span>`);
            }

            // Create badges HTML - show similarity badge if available
            let badgesHtml = '';
            if (feed.similarity !== undefined && feed.similarity !== null) {
                const similarityText = Math.round(feed.similarity * 100).toString();
                badgesHtml = `
                    <div class="badges-container">
                        <div class="similarity-badge score-badge">
                            ${similarityText}
                        </div>
                        <div class="score-badge" style="background-color: ${scoreColor};">
                            ${scoreText}
                            ${iconsHtml}
                        </div>
                    </div>
                `;
            } else {
                // No similarity score, just show the regular score badge
                badgesHtml = `
                    <div class="score-badge" style="background-color: ${scoreColor};">
                        ${scoreText}
                        ${iconsHtml}
                    </div>
                `;
            }

            return `
                <div class="feed-item" data-feed-rowid="${feed.rowid}" data-positive-votes="${feed.positive_votes || 0}" data-negative-votes="${feed.negative_votes || 0}" data-added="${feed.added}">
                    <div class="feed-header">
                        ${badgesHtml}
                        <div class="feed-content">
                            <div class="feed-title">${feed.title}</div>
                            <div class="feed-meta">
                                <div class="feed-meta-item feed-origin">${feed.origin || 'Unknown Source'}</div>
                                ${feed.author ? `<div class="feed-meta-item feed-author">${feed.author}</div>` : ''}
                                <div class="feed-meta-item feed-date">${formatDate(feed.published)}</div>
                            </div>
                        </div>
                        ${labels.length > 0 ? `<div class="feed-labels">${labels.join('')}</div>` : ''}
                    </div>
                    <div class="feed-details">
                        <div class="feed-abstract">Loading content...</div>
                        <div class="feed-actions">
                            ${feed.link ? `<a href="${feed.link}" target="_blank" class="btn btn-primary">üìÑ<span class="btn-text"> View Article</span></a>` : ''}
                            <button class="btn btn-star ${feed.starred ? 'starred' : ''}" onclick="starFeed(${feed.rowid}, this)" data-starred="${feed.starred ? 'true' : 'false'}">
                                ${feed.starred ? '‚òÖ' : '‚òÜ'}<span class="btn-text"> ${feed.starred ? 'Starred' : 'Star'}</span>
                            </button>
                            <button class="btn btn-thumbs-up ${feed.label === 1 ? 'active' : ''}" onclick="feedbackFeed(${feed.rowid}, 1, this)" data-label="${feed.label}">
                                üëç<span class="btn-text"> Interested</span>
                            </button>
                            <button class="btn btn-thumbs-down ${feed.label === 0 ? 'active' : ''}" onclick="feedbackFeed(${feed.rowid}, 0, this)" data-label="${feed.label}">
                                üëé<span class="btn-text"> Not Interested</span>
                            </button>
                            <button class="btn btn-similar" onclick="moreLikeThis(${feed.rowid})">
                                üîç<span class="btn-text"> More Like This</span>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function loadFeeds() {
            if (isLoading || !hasMore) return;

            isLoading = true;
            document.getElementById('loading').style.display = 'block';

            fetch(`/api/feeds?page=${currentPage}&limit=20&min_score=${currentMinScore}`)
                .then(response => response.json())
                .then(data => {
                    const feedsList = document.getElementById('feeds-list');

                    // Store bookmark ID and user preferences from first page load
                    if (currentPage === 1) {
                        if (data.bookmark_id !== undefined && data.bookmark_id !== null) {
                            bookmarkId = data.bookmark_id;
                        }
                        bookmarkInserted = false;
                    }

                    // Find the best position for bookmark
                    let bookmarkPosition = -1;
                    if (bookmarkId && !bookmarkInserted) {
                        // First, check if the exact bookmark exists in this batch
                        const exactIndex = data.feeds.findIndex(feed => feed.rowid === bookmarkId);

                        if (exactIndex !== -1) {
                            // Exact bookmark found
                            bookmarkPosition = exactIndex;
                        } else {
                            // Find the first feed that's newer than the bookmark
                            for (let i = 0; i < data.feeds.length; i++) {
                                if (data.feeds[i].rowid < bookmarkId) {
                                    bookmarkPosition = i; // Insert before this feed
                                    break;
                                }
                            }
                        }
                    }

                    // Process feeds and insert bookmark at the right position
                    data.feeds.forEach((feed, index) => {
                        const feedDateKey = getDateKey(feed.added);

                        // Insert bookmark divider BEFORE the feed at the calculated position
                        if (bookmarkId && !bookmarkInserted && index === bookmarkPosition) {
                            // Only show divider if this isn't the very first item shown
                            const totalItemsShown = (currentPage - 1) * 20 + index;
                            if (totalItemsShown > 0) {
                                const bookmarkDivider = `<div class="bookmark-divider">You were here</div>`;
                                feedsList.insertAdjacentHTML('beforeend', bookmarkDivider);
                                bookmarkInserted = true;
                            }
                        }

                        // Add date header if this is a new date
                        if (feedDateKey !== lastDateShown) {
                            const dateHeader = `<div class="date-header">${formatDateHeader(feed.added)}</div>`;
                            feedsList.insertAdjacentHTML('beforeend', dateHeader);
                            lastDateShown = feedDateKey;
                        }

                        feedsList.insertAdjacentHTML('beforeend', createFeedElement(feed));
                    });

                    hasMore = data.has_more;
                    currentPage++;

                    if (!hasMore) {
                        document.getElementById('loading').innerHTML = '<div style="padding: 20px; text-align: center; color: #7f8c8d;">No more feeds to load</div>';
                    } else {
                        document.getElementById('loading').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error loading feeds:', error);
                    document.getElementById('loading').innerHTML = '<div style="padding: 20px; text-align: center; color: #e74c3c;">Error loading feeds</div>';
                })
                .finally(() => {
                    isLoading = false;
                });
        }

        function loadFeedContent(feedRowid, detailsElement) {
            console.log('Loading content for feed rowid:', feedRowid);
            fetch(`/api/feeds/${feedRowid}/content`)
                .then(response => {
                    console.log('Response status:', response.status);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Content data:', data);
                    const abstractElement = detailsElement.querySelector('.feed-abstract');
                    if (data.content) {
                        abstractElement.textContent = data.content;
                    } else if (data.tldr) {
                        abstractElement.textContent = data.tldr;
                    } else {
                        abstractElement.textContent = 'No content available';
                    }
                })
                .catch(error => {
                    console.error('Error loading feed content:', error);
                    const abstractElement = detailsElement.querySelector('.feed-abstract');
                    abstractElement.textContent = `Error loading content: ${error.message}`;
                });
        }

        function starFeed(feedRowid, buttonElement) {
            // Prevent event bubbling to avoid triggering row expand/collapse
            event.stopPropagation();

            const isCurrentlyStarred = buttonElement.dataset.starred === 'true';

            // Optimistically update UI
            buttonElement.disabled = true;
            buttonElement.innerHTML = isCurrentlyStarred ? '‚òÖ<span class="btn-text"> Unstarring...</span>' : '‚òÜ<span class="btn-text"> Starring...</span>';

            fetch(`/api/feeds/${feedRowid}/star`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    action: 'toggle'
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    const feedItem = buttonElement.closest('.feed-item');
                    const labelsDiv = feedItem.querySelector('.feed-labels');

                    if (data.action === 'star') {
                        // Update button state to starred
                        buttonElement.dataset.starred = 'true';
                        buttonElement.innerHTML = '‚òÖ<span class="btn-text"> Starred</span>';
                        buttonElement.classList.add('starred');

                        // Add star label if not exists
                        if (labelsDiv && !labelsDiv.querySelector('.label-starred')) {
                            labelsDiv.insertAdjacentHTML('afterbegin', '<span class="label-badge label-starred">‚òÖ</span>');
                        } else if (!labelsDiv) {
                            const feedHeader = feedItem.querySelector('.feed-header');
                            feedHeader.insertAdjacentHTML('beforeend', '<div class="feed-labels"><span class="label-badge label-starred">‚òÖ</span></div>');
                        }
                    } else {  // unstar
                        // Update button state to unstarred
                        buttonElement.dataset.starred = 'false';
                        buttonElement.innerHTML = '‚òÜ<span class="btn-text"> Star</span>';
                        buttonElement.classList.remove('starred');

                        // Remove star label
                        if (labelsDiv) {
                            const starLabel = labelsDiv.querySelector('.label-starred');
                            if (starLabel) {
                                starLabel.remove();
                                // Remove labels div if empty
                                if (labelsDiv.children.length === 0) {
                                    labelsDiv.remove();
                                }
                            }
                        }
                    }
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
            })
            .catch(error => {
                console.error('Error toggling star:', error);
                // Revert UI changes on error
                buttonElement.innerHTML = isCurrentlyStarred ? '‚òÖ<span class="btn-text"> Starred</span>' : '‚òÜ<span class="btn-text"> Star</span>';
                alert('Failed to update star. Please try again.');
            })
            .finally(() => {
                buttonElement.disabled = false;
            });
        }

        function moreLikeThis(feedRowid) {
            // Prevent event bubbling to avoid triggering row expand/collapse
            event.stopPropagation();
            window.location.href = `/similar/${feedRowid}`;
        }

        function feedbackFeed(feedRowid, score, buttonElement) {
            // Prevent event bubbling to avoid triggering row expand/collapse
            event.stopPropagation();

            const currentLabel = parseFloat(buttonElement.dataset.label);
            const isRemoving = currentLabel === score;

            // Optimistically update UI
            buttonElement.disabled = true;
            const otherButton = score === 1
                ? buttonElement.nextElementSibling
                : buttonElement.previousElementSibling;
            if (otherButton && otherButton.classList.contains(score === 1 ? 'btn-thumbs-down' : 'btn-thumbs-up')) {
                otherButton.disabled = true;
            }

            fetch(`/api/feeds/${feedRowid}/feedback`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    score: isRemoving ? null : score
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    // Update button states
                    if (isRemoving) {
                        buttonElement.classList.remove('active');
                        buttonElement.dataset.label = '';
                    } else {
                        buttonElement.classList.add('active');
                        buttonElement.dataset.label = score;

                        // Remove active state from other button
                        if (otherButton && otherButton.classList.contains(score === 1 ? 'btn-thumbs-down' : 'btn-thumbs-up')) {
                            otherButton.classList.remove('active');
                            otherButton.dataset.label = '';
                        }
                    }

                    // Update labels in the header
                    const feedItem = buttonElement.closest('.feed-item');
                    let labelsDiv = feedItem.querySelector('.feed-labels');
                    const existingPositive = labelsDiv ? labelsDiv.querySelector('.label-positive') : null;
                    const existingNegative = labelsDiv ? labelsDiv.querySelector('.label-negative') : null;

                    // Get current vote counts from data attributes
                    let positiveCount = parseInt(feedItem.dataset.positiveVotes) || 0;
                    let negativeCount = parseInt(feedItem.dataset.negativeVotes) || 0;

                    // Adjust counts based on user action
                    if (isRemoving) {
                        if (score === 1) positiveCount = Math.max(0, positiveCount - 1);
                        else if (score === 0) negativeCount = Math.max(0, negativeCount - 1);
                    } else {
                        // Check if switching vote
                        const previousLabel = parseFloat(otherButton?.dataset.label);
                        if (previousLabel === 1 && score === 0) {
                            positiveCount = Math.max(0, positiveCount - 1);
                            negativeCount++;
                        } else if (previousLabel === 0 && score === 1) {
                            negativeCount = Math.max(0, negativeCount - 1);
                            positiveCount++;
                        } else if (score === 1) {
                            positiveCount++;
                        } else if (score === 0) {
                            negativeCount++;
                        }
                    }

                    // Update or remove labels based on new counts
                    if (!labelsDiv && (positiveCount > 0 || negativeCount > 0 || labelsDiv?.querySelector('.label-starred'))) {
                        const feedHeader = feedItem.querySelector('.feed-header');
                        feedHeader.insertAdjacentHTML('beforeend', '<div class="feed-labels"></div>');
                        labelsDiv = feedHeader.querySelector('.feed-labels');
                    }

                    // Update positive votes badge
                    if (positiveCount > 0) {
                        if (existingPositive) {
                            existingPositive.textContent = `+${positiveCount}`;
                        } else if (labelsDiv) {
                            labelsDiv.insertAdjacentHTML('beforeend', `<span class="label-badge label-positive">+${positiveCount}</span>`);
                        }
                    } else if (existingPositive) {
                        existingPositive.remove();
                    }

                    // Update negative votes badge
                    if (negativeCount > 0) {
                        if (existingNegative) {
                            existingNegative.textContent = `‚àí${negativeCount}`;
                        } else if (labelsDiv) {
                            labelsDiv.insertAdjacentHTML('beforeend', `<span class="label-badge label-negative">‚àí${negativeCount}</span>`);
                        }
                    } else if (existingNegative) {
                        existingNegative.remove();
                    }

                    // Remove labels div if empty
                    if (labelsDiv && labelsDiv.children.length === 0) {
                        labelsDiv.remove();
                    }

                    // Update the feed data attributes for consistency
                    feedItem.dataset.positiveVotes = positiveCount;
                    feedItem.dataset.negativeVotes = negativeCount;
                } else {
                    throw new Error(data.error || 'Unknown error');
                }
            })
            .catch(error => {
                console.error('Error updating feedback:', error);
                alert('Failed to update feedback. Please try again.');
            })
            .finally(() => {
                buttonElement.disabled = false;
                if (otherButton && otherButton.classList.contains(score === 1 ? 'btn-thumbs-down' : 'btn-thumbs-up')) {
                    otherButton.disabled = false;
                }
            });
        }

        // Event delegation for feed item clicks (works for both feed list and search results)
        document.addEventListener('click', function(e) {
            // Don't expand/collapse if clicking on buttons or links
            if (e.target.closest('button') || e.target.closest('a')) return;

            const feedItem = e.target.closest('.feed-item');
            if (!feedItem) return;

            const detailsElement = feedItem.querySelector('.feed-details');
            const isExpanded = feedItem.classList.contains('expanded');

            if (isExpanded) {
                // Collapse
                feedItem.classList.remove('expanded');
                detailsElement.classList.remove('expanded');
            } else {
                // Expand
                feedItem.classList.add('expanded');
                detailsElement.classList.add('expanded');

                // Load content if not already loaded
                const abstractElement = detailsElement.querySelector('.feed-abstract');
                if (abstractElement.textContent === 'Loading content...') {
                    loadFeedContent(feedItem.dataset.feedRowid, detailsElement);
                }
            }
        });

        // Infinite scroll
        window.addEventListener('scroll', function() {
            if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 1000) {
                loadFeeds();
            }
        });

        // Score filter functionality
        function updateScoreFilter() {
            const slider = document.getElementById('scoreSlider');
            const scoreValue = document.getElementById('scoreValue');
            const sliderValue = parseInt(slider.value);

            currentMinScore = scoreThresholds[sliderValue];
            scoreValue.textContent = scoreLabels[sliderValue];

            // Save preference to server
            fetch('/api/user/preferences', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    feedlist_minscore: currentMinScore
                })
            }).catch(error => {
                console.error('Failed to save preference:', error);
            });

            // Reset pagination and reload feeds
            currentPage = 1;
            hasMore = true;
            lastDateShown = null;
            bookmarkId = null;
            bookmarkInserted = false;
            document.getElementById('feeds-list').innerHTML = '';
            loadFeeds();
        }

        // Initialize slider
        function initializeSlider() {
            const slider = document.getElementById('scoreSlider');
            const scoreValue = document.getElementById('scoreValue');

            // Find the index that matches currentMinScore
            let initialIndex = scoreThresholds.indexOf(currentMinScore);
            if (initialIndex === -1) {
                // If exact match not found, find closest
                initialIndex = 0;
                let minDiff = Math.abs(scoreThresholds[0] - currentMinScore);
                for (let i = 1; i < scoreThresholds.length; i++) {
                    const diff = Math.abs(scoreThresholds[i] - currentMinScore);
                    if (diff < minDiff) {
                        minDiff = diff;
                        initialIndex = i;
                    }
                }
            }

            slider.value = initialIndex;
            scoreValue.textContent = scoreLabels[initialIndex];

            // Add event listener
            slider.addEventListener('input', updateScoreFilter);
        }

        // Primary channel selector
        function updatePrimaryChannel() {
            const selector = document.getElementById('primaryChannelSelect');
            const channelId = selector.value;

            // Save preference to server
            fetch('/api/user/preferences', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    primary_channel_id: channelId
                })
            }).then(response => {
                if (response.ok) {
                    // Reload the page to update broadcast badges
                    window.location.reload();
                }
            }).catch(error => {
                console.error('Failed to save primary channel:', error);
            });
        }

        // General search functions
        function toggleGeneralSearch() {
            const searchContainer = document.getElementById('generalSearchContainer');
            const feedsContainer = document.getElementById('feedsContainer');
            const searchResultsContainer = document.getElementById('generalSearchResultsContainer');
            const isHidden = searchContainer.style.display === 'none';

            if (isHidden) {
                searchContainer.style.display = 'block';
                feedsContainer.style.display = 'none';
                searchResultsContainer.style.display = 'none';
                document.getElementById('generalSearchInput').focus();
            } else {
                backToFeedList();
            }
        }

        function performGeneralSearch() {
            const query = document.getElementById('generalSearchInput').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            // Update URL with search query
            const newURL = new URL(window.location);
            newURL.searchParams.set('q', query);
            window.history.pushState({ path: newURL.toString() }, '', newURL.toString());

            // Show results container
            document.getElementById('generalSearchContainer').style.display = 'none';
            document.getElementById('generalSearchResultsContainer').style.display = 'block';

            const resultsDiv = document.getElementById('generalSearchResults');
            resultsDiv.innerHTML = '<div class="loading"><div class="loading-spinner"></div>Searching...</div>';

            fetch(`/api/search?q=${encodeURIComponent(query)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Search failed');
                    }
                    return response.json();
                })
                .then(data => {
                    currentSearchShortName = data.short_name || null;
                    displayGeneralSearchResults(data.feeds || []);
                })
                .catch(error => {
                    resultsDiv.innerHTML = `<div class="loading" style="color: #e74c3c;">Error: ${error.message}</div>`;
                });
        }

        let searchResultFeeds = [];  // Store search results for summary generation
        let currentSearchShortName = null;  // Store short name for current search

        function displayGeneralSearchResults(feeds) {
            const resultsDiv = document.getElementById('generalSearchResults');
            const query = document.getElementById('generalSearchInput').value.trim();

            // Update search query display
            const queryDisplay = document.getElementById('searchQueryDisplay');
            queryDisplay.textContent = `Query: "${query}"`;

            if (feeds.length === 0) {
                resultsDiv.innerHTML = '<div class="loading">No results found</div>';
                document.getElementById('searchSummarySection').style.display = 'none';
                return;
            }

            // Store feeds for summary generation
            searchResultFeeds = feeds;

            // Show summary section
            document.getElementById('searchSummarySection').style.display = 'block';

            resultsDiv.innerHTML = feeds.map(feed => createFeedElement(feed)).join('');
        }

        // Semantic Scholar search functions
        function toggleSemanticSearch() {
            const searchContainer = document.getElementById('semanticSearchContainer');
            const feedsContainer = document.getElementById('feedsContainer');
            const searchResultsContainer = document.getElementById('searchResultsContainer');
            const isHidden = searchContainer.style.display === 'none';

            if (isHidden) {
                searchContainer.style.display = 'block';
                feedsContainer.style.display = 'none';
                searchResultsContainer.style.display = 'none';
                document.getElementById('semanticSearchInput').focus();
            } else {
                backToFeedList();
            }
        }

        function copySearchLink() {
            let url;

            // Use shortened URL if available
            if (currentSearchShortName) {
                // Get base URL from current location
                const baseUrl = window.location.origin;
                url = `${baseUrl}/link/${currentSearchShortName}`;
            } else {
                // Fallback to full URL with query parameters
                url = window.location.href;
            }

            // Try modern clipboard API first
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(url).then(() => {
                    showToast('Link copied to clipboard!', 'success');
                }).catch(err => {
                    // Fallback to older method
                    fallbackCopyToClipboard(url);
                });
            } else {
                // Use fallback for older browsers or non-HTTPS
                fallbackCopyToClipboard(url);
            }
        }

        function fallbackCopyToClipboard(text) {
            // Create a temporary textarea element
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-999999px';
            textarea.style.top = '-999999px';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();

            try {
                const successful = document.execCommand('copy');
                const btn = event.target || document.querySelector('#generalSearchResultsContainer button[onclick*="copySearchLink"]');

                if (successful) {
                    showToast('Link copied to clipboard!', 'success');
                } else {
                    // Show error toast
                    showToast('Copy failed. Please manually copy the link.', 'error');
                }
            } catch (err) {
                // Show error toast
                showToast('Copy failed. Please manually copy the link.', 'error');
            } finally {
                document.body.removeChild(textarea);
            }
        }

        function backToFeedList() {
            document.getElementById('generalSearchContainer').style.display = 'none';
            document.getElementById('generalSearchResultsContainer').style.display = 'none';
            document.getElementById('semanticSearchContainer').style.display = 'none';
            document.getElementById('searchResultsContainer').style.display = 'none';
            document.getElementById('feedsContainer').style.display = 'block';

            // Clear search state
            currentSearchShortName = null;

            // Clear search query from URL
            const newURL = new URL(window.location);
            newURL.searchParams.delete('q');
            window.history.pushState({ path: newURL.toString() }, '', newURL.toString());

            // Load feeds if not already loaded
            const feedsList = document.getElementById('feeds-list');
            if (feedsList.children.length === 0) {
                currentPage = 1;
                hasMore = true;
                lastDateShown = null;
                loadFeeds();
            }
        }

        function backToSearchInput() {
            document.getElementById('searchResultsContainer').style.display = 'none';
            document.getElementById('semanticSearchContainer').style.display = 'block';
            document.getElementById('semanticSearchInput').focus();
        }

        function performSemanticSearch() {
            const query = document.getElementById('semanticSearchInput').value.trim();
            if (!query) {
                alert('Please enter a search query');
                return;
            }

            // Show results container
            document.getElementById('semanticSearchContainer').style.display = 'none';
            document.getElementById('searchResultsContainer').style.display = 'block';

            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.innerHTML = '<div class="loading"><div class="loading-spinner"></div>Searching scholarly database...</div>';

            // Try new endpoint first, fall back to legacy endpoint
            fetch('/api/scholarly-database/search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query: query })
            })
            .then(response => {
                if (!response.ok) {
                    if (response.status === 403) {
                        throw new Error('Admin access required');
                    }
                    throw new Error('Search failed');
                }
                return response.json();
            })
            .then(data => {
                if (data.success && data.papers) {
                    // Update title with provider name if available
                    if (data.provider) {
                        document.getElementById('searchResultsTitle').textContent = `${data.provider} Search Results`;
                    }
                    displaySearchResults(data.papers);
                } else {
                    resultsDiv.innerHTML = '<div class="loading">No results found</div>';
                }
            })
            .catch(error => {
                // Try legacy endpoint as fallback
                return fetch('/api/semantic-scholar/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ query: query })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.papers) {
                        displaySearchResults(data.papers);
                    } else {
                        resultsDiv.innerHTML = '<div class="loading">No results found</div>';
                    }
                })
                .catch(fallbackError => {
                    resultsDiv.innerHTML = `<div class="loading" style="color: #e74c3c;">Error: ${fallbackError.message}</div>`;
                });
            });
        }

        function displaySearchResults(papers) {
            const resultsDiv = document.getElementById('searchResults');

            if (papers.length === 0) {
                resultsDiv.innerHTML = '<div class="loading">No papers found</div>';
                return;
            }

            resultsDiv.innerHTML = papers.map(paper => {
                const authors = paper.authors ? paper.authors.map(a => a.name).join(', ') : '';
                const year = paper.year || 'Unknown Year';
                const venue = paper.venue || paper.journal?.name || 'Unknown Venue';
                const abstract = paper.abstract || (paper.tldr ? `(tl;dr) ${paper.tldr.text}` : 'No abstract available');

                // Build meta parts, filtering out empty values
                const metaParts = [];
                if (venue !== 'Unknown Venue') metaParts.push(`<strong>${venue}</strong>`);
                if (year !== 'Unknown Year') metaParts.push(year);
                if (authors) metaParts.push(authors);
                const metaLine = metaParts.join(' ‚Ä¢ ');

                return `
                    <div class="search-result-item">
                        <div class="search-result-title">${paper.title}</div>
                        ${metaLine ? `<div class="search-result-meta">${metaLine}</div>` : ''}
                        <div class="search-result-abstract">${abstract}</div>
                        <div class="search-result-actions">
                            ${paper.already_added
                                ? '<span class="already-added-badge">‚úì Already in database</span>'
                                : `<button class="btn btn-add" data-paper='${JSON.stringify(paper).replace(/'/g, '&apos;')}'>+ Add to Database</button>`
                            }
                            ${paper.url ? `<a href="${paper.url}" target="_blank" class="btn btn-primary">üìÑ View Paper</a>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Add event listeners to the "Add to Database" buttons
            resultsDiv.querySelectorAll('.btn-add').forEach(button => {
                button.addEventListener('click', function() {
                    const paperData = this.getAttribute('data-paper').replace(/&apos;/g, "'");
                    const paper = JSON.parse(paperData);
                    addPaperToDatabase(paper, this);
                });
            });
        }

        function addPaperToDatabase(paper, buttonElement) {

            buttonElement.disabled = true;
            buttonElement.textContent = 'Adding...';

            // Try new endpoint first, fall back to legacy endpoint
            fetch('/api/scholarly-database/add', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ paper: paper })
            })
            .then(response => {
                if (!response.ok) {
                    if (response.status === 409) {
                        throw new Error('Paper already exists in database');
                    }
                    throw new Error('Failed to add paper');
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    buttonElement.textContent = '‚úì Added';
                    buttonElement.className = 'btn btn-add';
                    buttonElement.disabled = true;

                    // Replace button with already added badge
                    setTimeout(() => {
                        buttonElement.parentElement.innerHTML = '<span class="already-added-badge">‚úì Already in database</span>';
                    }, 1000);
                } else {
                    throw new Error(data.message || 'Failed to add paper');
                }
            })
            .catch(error => {
                buttonElement.disabled = false;
                buttonElement.textContent = '+ Add to Database';
                alert(`Error: ${error.message}`);
            });
        }

        // Handle Enter key in search inputs
        document.addEventListener('DOMContentLoaded', function() {
            const generalSearchInput = document.getElementById('generalSearchInput');
            if (generalSearchInput) {
                generalSearchInput.addEventListener('keydown', function(e) {
                    // Submit on Enter without Shift
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        performGeneralSearch();
                    }
                    // Shift+Enter adds a new line (default behavior)
                });
            }

            const semanticSearchInput = document.getElementById('semanticSearchInput');
            if (semanticSearchInput) {
                semanticSearchInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        performSemanticSearch();
                    }
                });
            }

            // Summary generation for search results
            const generateSearchSummaryBtn = document.getElementById('generateSearchSummaryBtn');
            if (generateSearchSummaryBtn) {
                generateSearchSummaryBtn.addEventListener('click', function() {
                    const btn = this;
                    const summaryInitial = document.getElementById('searchSummaryInitial');
                    const summaryLoading = document.getElementById('searchSummaryLoading');
                    const summaryText = document.getElementById('searchSummaryText');

                    // Hide button container and show loading
                    summaryInitial.style.display = 'none';
                    summaryLoading.style.display = 'block';
                    summaryText.innerHTML = '';

                    // Extract feed IDs from search results (limit to top 20)
                    const feedIds = searchResultFeeds.slice(0, 20).map(feed => feed.rowid);

                    // Call the summarization API
                    fetch('/api/summarize', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ feed_ids: feedIds })
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            summaryText.innerHTML = data.summary_html + `
                                <div class="summary-disclaimer">
                                    <p><strong>Note:</strong> This AI-generated summary is based solely on article titles and abstracts, not the full text.
                                    The summary may contain inaccuracies or miss important details from the complete papers.
                                    Please refer to the original articles for comprehensive information.</p>
                                </div>
                            `;
                        } else {
                            summaryText.innerHTML = `<p style="color: #e74c3c;">Failed to generate summary: ${data.error || 'Unknown error'}</p>`;
                            // Show button again on failure
                            summaryInitial.style.display = 'flex';
                        }
                    })
                    .catch(error => {
                        console.error('Error generating summary:', error);
                        summaryText.innerHTML = '<p style="color: #e74c3c;">An error occurred while generating the summary.</p>';
                        // Show button again on error
                        summaryInitial.style.display = 'flex';
                    })
                    .finally(() => {
                        summaryLoading.style.display = 'none';
                    });
                });
            }

            // Poster generation for search results
            const generateSearchPosterBtn = document.getElementById('generateSearchPosterBtn');
            if (generateSearchPosterBtn) {
                generateSearchPosterBtn.addEventListener('click', function() {
                    const btn = this;
                    const summaryInitial = document.getElementById('searchSummaryInitial');
                    const posterLoading = document.getElementById('searchPosterLoading');
                    const summaryText = document.getElementById('searchSummaryText');
                    const posterContent = document.getElementById('searchPosterContent');

                    // Hide button container and show loading
                    summaryInitial.style.display = 'none';
                    posterLoading.style.display = 'block';
                    summaryText.style.display = 'none';
                    posterContent.style.display = 'none';

                    // Extract feed IDs from search results (limit to top 20)
                    const feedIds = searchResultFeeds.slice(0, 20).map(feed => feed.rowid);

                    // Call the poster generation API to queue the job

                    fetch('/api/generate-poster', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ feed_ids: feedIds })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(data => {
                                throw new Error(data.error || `HTTP error! status: ${response.status}`);
                            });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success && data.job_id) {
                            // Start polling for job completion
                            const jobId = data.job_id;
                            const pollInterval = setInterval(() => {
                                fetch(`/api/poster-status/${jobId}`)
                                    .then(response => {
                                        if (!response.ok) {
                                            throw new Error(`HTTP error! status: ${response.status}`);
                                        }
                                        return response.json();
                                    })
                                    .then(statusData => {
                                        if (statusData.status === 'completed') {
                                            clearInterval(pollInterval);
                                            posterLoading.style.display = 'none';

                                            // Create an iframe to display the HTML poster
                                            posterContent.innerHTML = `
                                                <iframe class="poster-iframe" srcdoc="${statusData.poster_html.replace(/"/g, '&quot;')}" frameborder="0"></iframe>
                                                <div class="summary-disclaimer">
                                                    <p><strong>Note:</strong> This AI-generated infographic is based solely on article titles and abstracts, not the full text.
                                                    The visualization may contain inaccuracies or miss important details from the complete papers.
                                                    Please refer to the original articles for comprehensive information.</p>
                                                </div>
                                            `;
                                            posterContent.style.display = 'block';

                                        } else if (statusData.status === 'error') {
                                            clearInterval(pollInterval);
                                            posterLoading.style.display = 'none';

                                            posterContent.innerHTML = `<p style="color: #e74c3c;">Failed to generate poster: ${statusData.error || 'Unknown error'}</p>`;
                                            posterContent.style.display = 'block';
                                            // Show button again on failure
                                            summaryInitial.style.display = 'flex';
                                        }
                                        // If status is 'pending' or 'processing', continue polling
                                    })
                                    .catch(error => {
                                        clearInterval(pollInterval);
                                        posterLoading.style.display = 'none';

                                        posterContent.innerHTML = `<p style="color: #e74c3c;">An error occurred while checking job status: ${error.message}</p>`;
                                        posterContent.style.display = 'block';
                                        // Show button again on error
                                        summaryInitial.style.display = 'flex';
                                    });
                            }, 3000); // Poll every 3 seconds

                            // Stop polling after 5 minutes
                            setTimeout(() => {
                                clearInterval(pollInterval);
                                if (posterLoading.style.display !== 'none') {
                                    posterLoading.style.display = 'none';
                                    posterContent.innerHTML = `<p style="color: #e74c3c;">Generation timed out. Please try again.</p>`;
                                    posterContent.style.display = 'block';
                                    summaryInitial.style.display = 'flex';
                                }
                            }, 300000); // 5 minutes timeout

                        } else {
                            throw new Error('Failed to create job');
                        }
                    })
                    .catch(error => {
                        posterLoading.style.display = 'none';
                        posterContent.innerHTML = `<p style="color: #e74c3c;">An error occurred while generating the poster: ${error.message}</p>`;
                        posterContent.style.display = 'block';
                        // Show button again on error
                        summaryInitial.style.display = 'flex';
                    });
                });
            }
        });

        // Track the highest visible feed ID for bookmark updates
        let highestVisibleFeedId = null;
        let bookmarkUpdateTimer = null;

        function updateBookmarkPosition() {
            // Find the topmost visible feed item
            const feedItems = document.querySelectorAll('.feed-item');
            let topVisibleFeed = null;

            for (const feedItem of feedItems) {
                const rect = feedItem.getBoundingClientRect();
                if (rect.top >= 0 && rect.top < window.innerHeight / 2) {
                    topVisibleFeed = feedItem;
                    break;
                }
            }

            if (topVisibleFeed) {
                const feedId = parseInt(topVisibleFeed.dataset.feedRowid);
                if (feedId && feedId !== highestVisibleFeedId) {
                    highestVisibleFeedId = feedId;

                    // Debounce bookmark updates
                    clearTimeout(bookmarkUpdateTimer);
                    bookmarkUpdateTimer = setTimeout(() => {
                        fetch('/api/user/bookmark', {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                feed_id: highestVisibleFeedId
                            })
                        }).catch(error => {
                            console.error('Failed to update bookmark:', error);
                        });
                    }, 2000); // Wait 2 seconds before updating
                }
            }
        }

        // Update bookmark on scroll
        window.addEventListener('scroll', updateBookmarkPosition);

        // Update bookmark when leaving the page
        window.addEventListener('beforeunload', function() {
            if (highestVisibleFeedId) {
                // Use sendBeacon for reliable updates when leaving
                const data = JSON.stringify({ feed_id: highestVisibleFeedId });
                navigator.sendBeacon('/api/user/bookmark', new Blob([data], { type: 'application/json' }));
            }
        });

        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(event) {
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('q');

            if (searchQuery) {
                // Show search results
                document.getElementById('generalSearchInput').value = searchQuery;
                toggleGeneralSearch();
                performGeneralSearch();
            } else {
                // Show feed list
                backToFeedList();
            }
        });

        // Check for search query in URL parameters
        function checkURLSearchParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const searchQuery = urlParams.get('q');

            if (searchQuery) {
                // Show search interface with the query
                document.getElementById('generalSearchInput').value = searchQuery;
                toggleGeneralSearch();
                // Perform the search automatically
                performGeneralSearch();
            }
        }

        // Initial load
        initializeSlider();

        // Initialize primary channel selector
        const primaryChannelSelect = document.getElementById('primaryChannelSelect');
        if (primaryChannelSelect) {
            primaryChannelSelect.addEventListener('change', updatePrimaryChannel);
        }

        checkURLSearchParams();
        // Only load feeds if not searching
        if (!new URLSearchParams(window.location.search).get('q')) {
            loadFeeds();
        }
    </script>
</body>
</html>
